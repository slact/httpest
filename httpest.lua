local setmetatable, tonumber, print, tcp, next, table, pairs = setmetatable, tonumber, print, tcp, next, table, pairslocal dispatcher = require "httpest.dispatcher"local http = require "httpest.sillyhttp"local socket = require "socket"local write, pcall = io.write, pcallmodule(...)local tcp=socket.tcplocal function receive(sock)	local l, err = sock:receive(response:whatnext())	if not l then 		return nil, err 	end	--print(l)	response:receive(l)	if response.complete then		if response.invalid then 			print(sock:receive("*a"))			print(response.invalid) 		end		--TODO: check connection-close and such		dispatcher.close_socket(sock)		if p.complete then 			p.complete(response) 			return l		else			print("nothing to complete")		end	end	return lendlocal clientpool, complete_callbacks, free_client_hosts= {}, setmetatable({}, {__mode='k'}), setmetatable({}, {__index = function(t,k) local v = setmetatable({}, {__mode='k'}) t[k]=v return v end})local clientcount = 0local function close(sock)	dispatcher.close_socket(sock)	clientpool[sock], complete_callbacks[sock] = nil, nil	clientcount = clientcount - 1endlocal function newclient(host, timeout)	local s, err= tcp()	if not s then return nil, err end	local host, port = host:match("([^:]+):?(%d*)")	s:settimeout(timeout or 1000)	local succ, err = s:connect(host, tonumber(port) or 80)	if not succ then		print("foo", succ)		print(err)		return nil, err 	end	local newresponse = sillyhttp.response.parser	local response = newresponse()	local receive = function(sock) 		local l, err = sock:receive(response:whatnext())		if not l then 						return nil, err 		end		//print(">> " .. l)		response:receive(l)		if response.complete then			local r = response			response = newresponse()			if r.invalid then 				print(r.invalid) 				close(sock)				return complete_callbacks[sock](r, "invalid")			end			return complete_callbacks[sock](r, "complete")		end		return l	end	dispatcher.register_client{		socket=s,		receive=receive	}	table.insert(clientpool, s)	clientcount = clientcount + 1	return sendlocal function getclient(host)	local sock = (next(free_client_hosts[host]))	if not sock then 		return newclient(host)	end	free_client_hosts[host][sock]=nil	return sockendlocal function freeclient(host, sock)	print(host, sock)	free_client_hosts[host][sock]=trueendfunction request(p, timeout)	local req = sillyhttp.request.new()	req.headers=p.headers or {}	req:seturl(p.uri or p.url)	req:setmethod(p.method)	req:setdata(p.data)	--what with the url checking	local host, port = (req:getheader("host") or ""):match("([^:]+):?(%d*)")	local auth = host .. ":" .. (#port==0 and 80 or port)	local sock, err = getclient(auth)	if not sock then return nil, err end	if timeout then		sock:settimeout(timeout)	end	local callback=p.complete	dispatcher.queue(sock, req:finish())	--print(clientcount)	complete_callbacks[sock]=function(r, status)		freeclient(auth, sock)		if (r:getheader("connection") or ""):lower():match('close') then			close(sock)		end		return callback(r, status)	end	return sockendlocal running_tests,tests, timed = {}, {}, {}function run()	while #tests>0 do		if #running_tests==0 then			runtest(next(tests[1]))			table.remove(tests, 1)		else			dispatcher.abort()			return true		end		dispatcher.step(1000)	endendfunction runtest(name, callback)	print("test " .. name)	local succ, res, err = pcall(callback)	if succ then 		return true 	else		return nil, res	endendfunction addtest(name, test)	table.insert(tests, {[name]=test})	return testend