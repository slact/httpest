local setmetatable, tonumber, print, tcp, next,  pairs = setmetatable, tonumber, print, tcp, next, pairslocal dispatcher = require "httpest.dispatcher"local http = require "httpest.sillyhttp"local socket = require "socket"local write, pcall = io.write, pcalllocal tostring, tinsert, tremove, assert = tostring, table.insert, table.remove, assertmodule(...)local tcp=socket.tcplocal function receive(sock)	local l, err = sock:receive(response:whatnext())	if not l then 		return nil, err 	end	response:receive(l)	if response.complete then		if response.invalid then 			print(response.invalid) 		end		--TODO: check connection-close and such		dispatcher.close_socket(sock)		if p.complete then 			p.complete(response) 			return l		else			print("nothing to complete")		end	end	return lendlocal clientpool, complete_callbacks, free_client_hosts= {}, setmetatable({}, {__mode='k'}), setmetatable({}, {__index = function(t,k) local v = setmetatable({}, {__mode='k'}) t[k]=v return v end})local clientcount = 0local function killclient(host, sock)	free_client_hosts[host][sock]=nil	dispatcher.close_socket(sock)	clientpool[sock], complete_callbacks[sock] = nil, nil	clientcount = clientcount - 1	endlocal newresponse = sillyhttp.response.parserlocal function newclient(host, timeout)	local s, err= tcp()	if not s then return nil, err end	local host, port = host:match("([^:]+):?(%d*)")	s:settimeout(timeout or 1000)	local succ, err = s:connect(host, tonumber(port) or 80)	if not succ then		print(err)		return nil, err 	end	local response = newresponse()	local receive = function(sock) 		local l, err = sock:receive(response:whatnext())		if not l then 						return nil, err 		end		--print(">> " .. l)		response:receive(l)		if response.complete then			local r = response			response = newresponse()			if r.invalid then 				print("INVALID RESPONSE", r.invalid) 				killclient(host, sock)				return complete_callbacks[sock](r, "invalid")			end			return complete_callbacks[sock](r)		end		return l	end	dispatcher.register_client{		socket=s,		receive=receive	}	tinsert(clientpool, s)	clientcount = clientcount + 1	return sendlocal function getclient(host)	local sock = (next(free_client_hosts[host]))	if not sock then 		return newclient(host)	end	free_client_hosts[host][sock]=nil	return sockendlocal function freeclient(host, sock)	complete_callbacks[sock]=nil	free_client_hosts[host][sock]=trueendfunction request(p, timeout)	local req = sillyhttp.request.new()	req.headers=p.headers or {}	req:seturl(p.uri or p.url)	req:setmethod(p.method)	req:setdata(p.data)	--what with the url checking	local host, port = (req:getheader("host") or ""):match("([^:]+):?(%d*)")	local auth = host .. ":" .. (#port==0 and 80 or port)	local sock, err = getclient(auth)	if not sock then return nil, err end	if timeout then		sock:settimeout(timeout)	end	local callback=p.complete	dispatcher.queue(sock, req:finish())	complete_callbacks[sock]=function(r, status)		freeclient(auth, sock)		if (r:getheader("connection") or ""):lower():match('close') then			killclient(auth, sock)		end		return callback(r, status)	end	return sockendlocal tests, timed = {}, {}local function runtest(name, callback)	print("test: " .. name)	local succ, res, err = pcall(callback)	if res==true then 		print("ok")	elseif res==false then		print("fail")	elseif not succ then		print("fail: " .. (res or "(?)"))	endendfunction run()	while #tests>0 do		if not (next(complete_callbacks)) then			local nextname, nexttest = next(tests[1])			if not nextname then				dispatcher.abort()				return false			end			runtest(nextname, nexttest)			tremove(tests, 1)		end		dispatcher.step(1000)	endendfunction addtest(name, test)	tinsert(tests, {[name]=test})	return testend