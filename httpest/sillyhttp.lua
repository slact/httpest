local error, tonumber, tostring, rawset, rawget = error, tonumber, tostring, rawset, rawgetlocal type, coroutine, setmetatable = type, coroutine, setmetatablelocal pairs, tinsert, tconcat, print = pairs, table.insert, table.concat, printlocal byte,date = string.byte, os.datelocal match = string.matchlocal function assert(t, err) --quietly assert stuff	if not t then error(err, 0) endendmodule(...)request, response = {}, {}local function trim( aValue )    return ( aValue:gsub( '^[%c%s]+', '' ):gsub( '[%s%c]+$', '' ) )endlocal function receive(self, whatdoyouneed)	return coroutine.yield(whatdoyouneed)endlocal function parse_complete(self)	return trueendlocal parse_headerslocal function parse_chunk(self, buffer)	local size = tonumber(match(receive(self, "*l"), "^(%x+)") or "", 16)	assert(size, "invalid chunk size " .. tostring(size or "(?)"))	if size~=0 then		tinsert(buffer, receive(self, size))		assert(receive(self, "*l"), "improperly formatted chunk") --blank line after the chunk		return true	end	return falseend--hopefully read content-type:chunked thingslocal function parse_chunked_body(self)	local buffer = {}	repeat until not parse_chunk(self, buffer)	self.body=tconcat(buffer)	return parse_headers(self, parse_complete) --footers now.endlocal function parse_body(self)	if (tonumber(self:getheader("content-length")) or 0)>0 then		local res = receive(self, tonumber(self:getheader("content-length")))		if res then 			self.body=res		end		return parse_complete(self)	elseif (self:getheader('transfer-encoding') or ""):lower()=='chunked' then		return parse_chunked_body(self)	endendparse_headers=function(self, when_done, last_header)	local line = receive(self, "*l")	assert(line, "no input line")	if #line==0 then --blank line  -- move on		return (when_done or parse_body)(self)	else		--check for folded headers		local folded = line:match("^(%s.+)$")		if folded and last_header then			self:setheader(last_header, self:getheader(last_header) .. folded)			return parse_headers(self, when_done, last_header)		end		--parse a header		local key, val = line:match( '(%S-): (.*)' )		if key then			local key = trim( key ):lower()			val = trim( val )			local before = self:getheader(key)			if before then				val = before .. ',' .. val			end			self:setheader(key, val)			return parse_headers(self, when_done, key)		end		assert(nil, "invalid header line")	endendlocal function parse_request_line(self)	local line, err = receive(self, "*l")	assert(line, "couldn't obtain request line")	local Method, Request_URI, HTTP_Version = line:match("^(%S+) (%S+) (HTTP/%d+%.%d+)")	assert(Method and Request_URI and HTTP_Version, "invalid request line")	rawset(self, "request-line", line)	for i, v in pairs{method=Method, url=Request_URI, version=HTTP_Version} do		rawset(self, i, v)		rawset(self, "get" .. i , function(self) return self[i] end)	end	return parse_headers(self)endlocal function parse_response_line(self)	local line, err = receive(self, "*l")	assert(line, "couldn't obtain response line")	local HTTP_version, Status_Code, Reason_Phrase = line:match("^(HTTP/%d+%.%d+) (%d+) ?(.*)")	assert(HTTP_version and Status_Code and Reason_Phrase, "invalid response line - " .. line)	rawset(self, "status-line", line)	for i, v in pairs{version=HTTP_version, status=tonumber(Status_Code), reason=(Reason_Phrase or "")} do		rawset(self, i, v)		rawset(self, "get" .. i , function(self) return self[i] end)	end	return parse_headers(self)endlocal function getheader(self, header)	if type(header)~="string" then return nil, "not a string" end	return (self.headers[header:lower()])endlocal function setheader(self, header, value)	self.headers[header]=value	return selfendlocal bake_me_a_parser do	local function diddly_squat() return nil, "nothing left to do here" end	local parser_mt = {__index=getheader, __tostring=function(self)		local b = {}		if rawget(self, "status-line") then tinsert(b, rawget(self, "status-line")) end		for h, v in pairs(self.headers) do			tinsert(b, h .. ": " .. v)		end		tinsert(b, "")		if self.body then tinsert(b, self.body) end		return tconcat(b)	end}	local create, resume, status = coroutine.create, coroutine.resume, coroutine.status	bake_me_a_parser = function(coroutine_body)		return function()			local parser=create(coroutine_body)			local readnext			local receive = function(self, data, err)				if data==nil then return nil, (err or "no data") end				local s, res=resume(parser, data)				readnext=res				if not s then					self.invalid = res				end				if status(parser)=="dead" then --we're done!					self.receive=diddly_squat -- no more receiving, sirs.					self.complete=true					return true				end				return res			end			local parser_object = setmetatable({				headers={},				receive=receive,				getheader=getheader,				setheader=setheader,				getbody=function(self)					return self.body				end,				whatnext=function()					return readnext				end			}, parser_mt)			receive(parser_object, parser_object)			return parser_object		end	endendrequest.parser = bake_me_a_parser(parse_request_line)response.parser = bake_me_a_parser(parse_response_line)--- NOW THE GENERATORS -----local setstatus; do	local status_codes = {		[100]="Continue", [101]="Switching Protocols", 				[200]="OK", [201]="Created", [202]="Accepted", 		[203]="Non-Authoritative Information", [204]="No Content", [206]="Partial Content", 				[300]="Multiple Choices", [301]="Moved Permanently", [302]="Found", [303]="See Other", 		[304]="Not Modified", [305]="Use Proxy", [306]="", [307]="Temporary Redirect", 				[400]="Bad Request", [401]="Unauthorized", [402]="Payment Required", [403]="Forbidden", 		[404]="Not Found", [405]="Method Not Allowed", [406]="Not Acceptable", 		[407]="Proxy Authentication Required", [408]="Request Timeout", [409]="Conflict", [410]="Gone", 		[411]="Length Required", [412]="Precondition Failed", [413]="Request Entity Too Large", 		[414]="Request-URI Too Long", [415]="Unsupported Media Type", 		[416]="Request Range Not Satisfiable", [417]="Expectation Failed",				[500]="Internal Server Error", [501]="Not Implemented", [502]="Bad Gateway", 		[503]="Service Unavailable", [504]="Gateway Timeout", [505]="HTTP Version Not Supported"	}	function setstatus(self, status)		local reason		if type(status)=="string" then			status, reason = status:match("^(%d+) (.*)")			status = tonumber(status)		end		if type(status)=="number" then			self.status = status			self.reason = reason or status_codes[status] or ""		else			return nil, "invalid status"		end		return self	endendlocal function capitalize( aValue )    return aValue:lower():gsub( '(%l)([%w_\']*)', function( first, second )		return first:upper() .. second	end)endlocal function process_data(self)	local function urlencode(s)		return tostring(s):gsub("([^A-Za-z0-9_])", function(c)			return ("%%%02x"):format(byte(c))		end)	end	local d, b=self.data, {}	if type(d)=="table" then		self:setheader("content-type", "application/x-www-form-urlencoded")		for i, v in pairs(d) do			tinsert(b, ("%s=%s"):format(urlencode(i), urlencode(v)))		end		return tconcat(b, "&")	else		return d	endendlocal function writer_generator(statusline_maker)	local buffer = {}	local response	return 		function(self, msg) --writer			if response then 				return nil, "too late -- response is already finished" 			end			tinsert(buffer, msg)			return self		end , 		function(self) --finisher			if response then return response end			local tb = {}			tinsert(tb, statusline_maker(self))						local body = tconcat(buffer)			if #body==0 and self.data then				body=process_data(self)			end			buffer = {}			self:setheader("content-length", #body)						for header, value in pairs(self.headers) do				tinsert(tb, ("%s: %s"):format(capitalize(header), value))			end			tinsert(tb,"")			tinsert(tb, body)			response = tconcat(tb, "\r\n")			return response		endendlocal function make_response_line(self)	if not self:getheader("date") then		self:setheader("date", date("!%a, %d %b %G %T GMT"))	end	return ("%s %s %s"):format(self.version, self.status, self.reason)endlocal function make_request_line(self)	return ("%s %s %s"):format(self.method, self.url, self.version)end--[[	response maker:	local resp = sillyhttp.response.new()	resp:setheader("foo", "bar")	resp.foo=bar --same as previous line.		analogous for getheader and resp[ ... ], unless, of course, the index 	is one of 'headers', 'getheader', 'setheader', 'setstatus', 'write', or 'finish'	resp:write("stuff that goes into the body")		local entire_response = resp:finish() --makes further writing impossible. 		--sets content-length and such, and returns the full response string.]]local make_mt={__index=getheader,__newindex=setheader}response.new = function()	local writer, finisher = writer_generator(make_response_line)	local t = setmetatable({		headers={},		getheader = getheader,		setheader = setheader,		setstatus = setstatus,		version="HTTP/1.1",		status=200,		reason="OK",		write = writer, --write to response body		finish = finisher --finishes everything, returns entire response string	}, make_mt)	return tendrequest.new = function()	local writer, finisher = writer_generator(make_request_line)	local t = setmetatable({		headers={},		getheader = getheader,		setheader = setheader,		method="GET",		url="",		version="HTTP/1.1",		data=false,		setdata=function(self, d)			rawset(self, "data", d)		end,		seturl=function(self, url)			if url:match("^https?://") then --absolute				local authority				authority, url=url:match("^https?://([^/]+)/?(.*)")				self:setheader("host", authority)			end			rawset(self, "url", '/' .. url)			return self		end,		geturl=function(self)			return self.url		end,		setmethod=function(self, method)			if  type(method)~="string" then 				return nil, "method parameter must be a string" 			end			rawset(self, "method", method:upper())			return self		end,		write = writer, --write to request body		finish = finisher --finishes everything, returns entire request string	}, make_mt)	return tend